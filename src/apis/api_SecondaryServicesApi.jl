# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct SecondaryServicesApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `SecondaryServicesApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ SecondaryServicesApi }) = "https://openeo.example/api/v1"

const _returntypes_create_service_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_create_service(_api::SecondaryServicesApi, request_body::Dict{String, Any}; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_create_service_SecondaryServicesApi, "/services", ["Bearer", ], request_body)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Publish a new service

Creates a new secondary web service such as a [OGC WMS](http://www.opengeospatial.org/standards/wms), [OGC WCS](http://www.opengeospatial.org/standards/wcs), [OGC API - Features](https://www.ogc.org/standards/ogcapi-features) or [XYZ tiles](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames).  The secondary web service SHOULD process the underlying data on demand, based on process parameters provided to the user-defined process (through `from_parameter` references) at run-time, for example for the spatial/temporal extent, resolution, etc. The available process parameters are specified per service type at `GET /service_types`.  **Note:** Costs incurred by shared secondary web services are usually paid by the owner, but this depends on the service type and whether it supports charging fees or not.

Params:
- request_body::Dict{String, Any} (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function create_service(_api::SecondaryServicesApi, request_body::Dict{String, Any}; _mediaType=nothing)
    _ctx = _oacinternal_create_service(_api, request_body; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function create_service(_api::SecondaryServicesApi, response_stream::Channel, request_body::Dict{String, Any}; _mediaType=nothing)
    _ctx = _oacinternal_create_service(_api, request_body; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_debug_service_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => LogEntries,
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_debug_service(_api::SecondaryServicesApi, service_id::String; offset=nothing, level=nothing, limit=nothing, _mediaType=nothing)

    OpenAPI.validate_param("limit", "debug_service", :minimum, limit, 1, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_debug_service_SecondaryServicesApi, "/services/{service_id}/logs", ["Bearer", ])
    OpenAPI.Clients.set_param(_ctx.path, "service_id", service_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "offset", offset)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "level", level)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Logs for a secondary service

Lists log entries for the secondary service, usually for debugging purposes. Back-ends can log any information that may be relevant for a user. Users can log information during data processing using respective processes such as `inspect`. If requested consecutively while the secondary service is enabled, it is RECOMMENDED that clients use the offset parameter to get only the entries they have not received yet. While pagination itself is OPTIONAL, the `offset` parameter is REQUIRED to be implemented by back-ends.

Params:
- service_id::String (required)
- offset::String
- level::String
- limit::Int64

Return: LogEntries, OpenAPI.Clients.ApiResponse
"""
function debug_service(_api::SecondaryServicesApi, service_id::String; offset=nothing, level=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_debug_service(_api, service_id; offset=offset, level=level, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function debug_service(_api::SecondaryServicesApi, response_stream::Channel, service_id::String; offset=nothing, level=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_debug_service(_api, service_id; offset=offset, level=level, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_delete_service_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("204", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_delete_service(_api::SecondaryServicesApi, service_id::String; _mediaType=nothing)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_delete_service_SecondaryServicesApi, "/services/{service_id}", ["Bearer", ])
    OpenAPI.Clients.set_param(_ctx.path, "service_id", service_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Delete a service

Deletes all data related to this secondary web service. Computations are stopped, computed results are deleted and access to this is not possible any more. This service won't generate additional costs.

Params:
- service_id::String (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function delete_service(_api::SecondaryServicesApi, service_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_service(_api, service_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function delete_service(_api::SecondaryServicesApi, response_stream::Channel, service_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_service(_api, service_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_describe_service_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => DescribeService200Response,
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_describe_service(_api::SecondaryServicesApi, service_id::String; _mediaType=nothing)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_describe_service_SecondaryServicesApi, "/services/{service_id}", ["Bearer", ])
    OpenAPI.Clients.set_param(_ctx.path, "service_id", service_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Full metadata for a service

Lists all information about a secondary web service.

Params:
- service_id::String (required)

Return: DescribeService200Response, OpenAPI.Clients.ApiResponse
"""
function describe_service(_api::SecondaryServicesApi, service_id::String; _mediaType=nothing)
    _ctx = _oacinternal_describe_service(_api, service_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function describe_service(_api::SecondaryServicesApi, response_stream::Channel, service_id::String; _mediaType=nothing)
    _ctx = _oacinternal_describe_service(_api, service_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_service_types_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Dict{String, ServiceTypes},
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_list_service_types(_api::SecondaryServicesApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_service_types_SecondaryServicesApi, "/service_types", ["Bearer", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Supported secondary web service protocols

Lists supported secondary web service protocols such as [OGC WMS](http://www.opengeospatial.org/standards/wms), [OGC WCS](http://www.opengeospatial.org/standards/wcs), [OGC API - Features](https://www.ogc.org/standards/ogcapi-features) or [XYZ tiles](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames). The response is an object of all available secondary web service protocols with their supported configuration settings and expected process parameters.  * The configuration settings for the service SHOULD be defined upon   creation of a service and the service will be set up accordingly. * The process parameters SHOULD be referenced (with a `from_parameter`   reference) in the user-defined process that is used to compute web service   results.   The appropriate arguments MUST be provided to the user-defined process,   usually at runtime from the context of the web service,   For example, a map service such as a WMS would   need to inject the spatial extent into the user-defined process so that the   back-end can compute the corresponding tile correctly.  To improve interoperability between back-ends common names for the services SHOULD be used, e.g. the abbreviations used in the official [OGC Schema Repository](http://schemas.opengis.net/) for the respective services.  Service names MUST be accepted in a *case insensitive* manner throughout the API.

Params:

Return: Dict{String, ServiceTypes}, OpenAPI.Clients.ApiResponse
"""
function list_service_types(_api::SecondaryServicesApi; _mediaType=nothing)
    _ctx = _oacinternal_list_service_types(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_service_types(_api::SecondaryServicesApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_list_service_types(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_services_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SecondaryWebServices,
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_list_services(_api::SecondaryServicesApi; limit=nothing, _mediaType=nothing)
    OpenAPI.validate_param("limit", "list_services", :minimum, limit, 1, false)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_services_SecondaryServicesApi, "/services", ["Bearer", ])
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""List all web services

Lists all secondary web services submitted by a user.  It is **strongly RECOMMENDED** to keep the response size small by omitting all optional non-scalar values (i.e. arrays and objects) from objects in `services` (i.e. the `process`, `configuration` and `attributes` properties). To get the full metadata for a secondary web service clients MUST request `GET /services/{service_id}`.

Params:
- limit::Int64

Return: SecondaryWebServices, OpenAPI.Clients.ApiResponse
"""
function list_services(_api::SecondaryServicesApi; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_services(_api; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_services(_api::SecondaryServicesApi, response_stream::Channel; limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_services(_api; limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_service_SecondaryServicesApi = Dict{Regex,Type}(
    Regex("^" * replace("204", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("4XX", "x"=>".") * "\$") => Error,
    Regex("^" * replace("5XX", "x"=>".") * "\$") => Error,
)

function _oacinternal_update_service(_api::SecondaryServicesApi, service_id::String, update_secondary_web_service_request::UpdateSecondaryWebServiceRequest; _mediaType=nothing)

    _ctx = OpenAPI.Clients.Ctx(_api.client, "PATCH", _returntypes_update_service_SecondaryServicesApi, "/services/{service_id}", ["Bearer", ], update_secondary_web_service_request)
    OpenAPI.Clients.set_param(_ctx.path, "service_id", service_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Modify a service

Modifies an existing secondary web service at the back-end, but maintain the identifier. Changes can be grouped in a single request.  User have to create a new service to change the service type.

Params:
- service_id::String (required)
- update_secondary_web_service_request::UpdateSecondaryWebServiceRequest (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function update_service(_api::SecondaryServicesApi, service_id::String, update_secondary_web_service_request::UpdateSecondaryWebServiceRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_service(_api, service_id, update_secondary_web_service_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_service(_api::SecondaryServicesApi, response_stream::Channel, service_id::String, update_secondary_web_service_request::UpdateSecondaryWebServiceRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_service(_api, service_id, update_secondary_web_service_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export create_service
export debug_service
export delete_service
export describe_service
export list_service_types
export list_services
export update_service
